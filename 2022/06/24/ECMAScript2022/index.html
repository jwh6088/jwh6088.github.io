<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="2022年6月22日，第123届ECMA大会批准了ECMAScript2022语言规范，这意味着它现在正式成为标准。以下整理了ECMAScript2022的新特性。">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript2022新特性整理">
<meta property="og:url" content="http://example.com/2022/06/24/ECMAScript2022/index.html">
<meta property="og:site_name" content="江南织造总局">
<meta property="og:description" content="2022年6月22日，第123届ECMA大会批准了ECMAScript2022语言规范，这意味着它现在正式成为标准。以下整理了ECMAScript2022的新特性。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-24T08:55:07.000Z">
<meta property="article:modified_time" content="2022-06-24T08:55:07.000Z">
<meta property="article:author" content="jwh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/06/24/ECMAScript2022/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ECMAScript2022新特性整理 | 江南织造总局</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江南织造总局</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/ECMAScript2022/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="jwh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南织造总局">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ECMAScript2022新特性整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-24 16:55:07" itemprop="dateCreated datePublished" datetime="2022-06-24T16:55:07+08:00">2022-06-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javasript/" itemprop="url" rel="index"><span itemprop="name">Javasript</span></a>
                </span>
            </span>

          
            <div class="post-description">2022年6月22日，第123届ECMA大会批准了ECMAScript2022语言规范，这意味着它现在正式成为标准。以下整理了ECMAScript2022的新特性。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h5 id="Top-level-Await"><a href="#Top-level-Await" class="headerlink" title="Top-level Await"></a>Top-level Await</h5><p>在ES2017中，引入了 async 函数和 await 关键字，以简化 Promise 的使用，但是 await 关键字只能在 async 函数内部使用。尝试在异步函数之外使用 await 就会报错：SyntaxError - SyntaxError: await is only valid in async function。<br>顶层 await 允许我们在 async 函数外面使用 await 关键字。它允许模块充当大型异步函数，通过顶层 await，这些 ECMAScript 模块可以等待资源加载。这样其他导入这些模块的模块在执行代码之前要等待资源加载完再去执行。<br>由于 await 仅在 async 函数中可用，因此模块可以通过将代码包装在 async 函数中来在代码中包含 await：</p>
<pre><code class="javascript">// a.js
import fetch  from &quot;node-fetch&quot;;
let users;
export const fetchUsers = async () =&gt; &#123;
    const resp = await fetch(&#39;https://jsonplaceholder.typicode.com/users&#39;);
    users =  resp.json();
&#125;
fetchUsers();
export &#123; users &#125;;

// usingAwait.js
import &#123;users&#125; from &#39;./a.js&#39;;
console.log(&#39;users: &#39;, users);
console.log(&#39;usingAwait module&#39;);
</code></pre>
<p>我们还可以立即调用顶层async函数（IIAFE）：</p>
<pre><code class="javascript">import fetch  from &quot;node-fetch&quot;;
  (async () =&gt; &#123;
    const resp = await fetch(&#39;https://jsonplaceholder.typicode.com/users&#39;);
    users = resp.json();
  &#125;)();
  export &#123; users &#125;;
</code></pre>
<p>这样会有一个缺点，直接导入的 users 是 undefined，需要在异步执行完成之后才能访问它：</p>
<pre><code class="javascript">// usingAwait.js
import &#123;users&#125; from &#39;./a.js&#39;;
console.log(&#39;users:&#39;, users); // undefined
setTimeout(() =&gt; &#123;
  console.log(&#39;users:&#39;, users);
&#125;, 100);
console.log(&#39;usingAwait module&#39;);
</code></pre>
<p>当然，这种方法并不安全，因为如果异步函数执行花费的时间超过100毫秒， 它就不会起作用了，users 仍然是 undefined。<br>另一个方法是导出一个 promise，让导入模块知道数据已经准备好了：</p>
<pre><code class="javascript">//a.js
import fetch  from &quot;node-fetch&quot;;
export default (async () =&gt; &#123;
  const resp = await fetch(&#39;https://jsonplaceholder.typicode.com/users&#39;);
  users = resp.json();
&#125;)();
export &#123; users &#125;;

//usingAwait.js
import promise, &#123;users&#125; from &#39;./a.js&#39;;
promise.then(() =&gt; &#123; 
  console.log(&#39;usingAwait module&#39;);
  setTimeout(() =&gt; console.log(&#39;users:&#39;, users), 100); 
&#125;);
</code></pre>
<p>虽然这种方法似乎是给出了预期的结果，但是有一定的局限性：导入模块必须了解这种模式才能正确使用它。<br>而顶层await就可以解决这些问题：</p>
<pre><code class="javascript">// a.js
const resp = await fetch(&#39;https://jsonplaceholder.typicode.com/users&#39;);
const users = resp.json();
export &#123; users&#125;;

// usingAwait.js
import &#123;users&#125; from &#39;./a.mjs&#39;;
console.log(users);
console.log(&#39;usingAwait module&#39;);
</code></pre>
<p>顶级 await 在以下场景中将非常有用：<br>动态加载模块：</p>
<pre><code class="javascript"> const strings = await import(`/i18n/$&#123;navigator.language&#125;`);
</code></pre>
<p>资源初始化：</p>
<pre><code class="javascript">const connection = await dbConnector();
</code></pre>
<p>依赖回退：</p>
<pre><code class="javascript">let translations;
try &#123;
  translations = await import(&#39;https://app.fr.json&#39;);
&#125; catch &#123;
  translations = await import(&#39;https://fallback.en.json&#39;);
&#125;
</code></pre>
<h5 id="Object-hasOwn"><a href="#Object-hasOwn" class="headerlink" title="Object.hasOwn()"></a>Object.hasOwn()</h5><p>在ES2022之前，可以使用 Object.prototype.hasOwnProperty() 来检查一个属性是否属于对象。<br>Object.hasOwn 特性是一种更简洁、更可靠的检查属性是否直接设置在对象上的方法：</p>
<pre><code class="javascript">const example = &#123;
  property: &#39;123&#39;
&#125;;

console.log(Object.prototype.hasOwnProperty.call(example, &#39;property&#39;));
console.log(Object.hasOwn(example, &#39;property&#39;));
</code></pre>
<h5 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h5><p>at() 是一个数组方法，用于通过给定索引来获取数组元素。当给定索引为正时，这种新方法与使用括号表示法访问具有相同的行为。当给出负整数索引时，就会从数组的最后一项开始检索：</p>
<pre><code class="javascript">const array = [0,1,2,3,4,5];

console.log(array[array.length-1]);  // 5
console.log(array.at(-1));  // 5

console.log(array[array.lenght-2]);  // 4
console.log(array.at(-2));  // 4
</code></pre>
<p>除了数组，字符串也可以使用at()方法进行索引：</p>
<pre><code class="javascript">const str = &quot;hello world&quot;;

console.log(str[str.length - 1]);  // d
console.log(str.at(-1));  // d
</code></pre>
<h5 id="error-cause"><a href="#error-cause" class="headerlink" title="error.cause"></a>error.cause</h5><p>在 ECMAScript 2022 规范中，new Error() 中可以指定导致它的原因：</p>
<pre><code class="javascript">function readFiles(filePaths) &#123;
  return filePaths.map(
    (filePath) =&gt; &#123;
      try &#123;
        // ···
      &#125; catch (error) &#123;
        throw new Error(
          `While processing $&#123;filePath&#125;`,
          &#123;cause: error&#125;
        );
      &#125;
    &#125;);
&#125;
</code></pre>
<h5 id="正则表达式匹配索引"><a href="#正则表达式匹配索引" class="headerlink" title="正则表达式匹配索引"></a>正则表达式匹配索引</h5><p>该特性允许我们利用 d 字符来表示我们想要匹配字符串的开始和结束索引。以前，只能在字符串匹配操作期间获得一个包含提取的字符串和索引信息的数组。在某些情况下，这是不够的。因此，在这个规范中，如果设置标志 /d，将额外获得一个带有开始和结束索引的数组。</p>
<pre><code class="javascript">const matchObj = /(a+)(b+)/d.exec(&#39;aaaabb&#39;);

console.log(matchObj[1]) // &#39;aaaa&#39;
console.log(matchObj[2]) // &#39;bb&#39;
</code></pre>
<p>由于 /d 标识的存在，matchObj还有一个属性.indices，它用来记录捕获的每个编号组：</p>
<pre><code class="javascript">console.log(matchObj.indices[1])  // [0, 4]
console.log(matchObj.indices[2])  // [4, 6]
</code></pre>
<p>我们还可以使用命名组：</p>
<pre><code class="javascript">const matchObj = /(?&lt;as&gt;a+)(?&lt;bs&gt;b+)/d.exec(&#39;aaaabb&#39;);

console.log(matchObj.groups.as);  // &#39;aaaa&#39;
console.log(matchObj.groups.bs);  // &#39;bb&#39;
</code></pre>
<p>这里给两个字符匹配分别命名为as和bs，然后就可以通过groups来获取到这两个命名分别匹配到的字符串。<br>它们的索引存储在 matchObj.indices.groups 中：</p>
<pre><code class="javascript">console.log(matchObj.indices.groups.as);  // [0, 4]
console.log(matchObj.indices.groups.bs);  // [4, 6]
</code></pre>
<p>匹配索引的一个重要用途就是指向语法错误所在位置的解析器。下面的代码解决了一个相关问题：它指向引用内容的开始和结束位置。</p>
<pre><code class="javascript">const reQuoted = /“([^”]+)”/dgu;
function pointToQuotedText(str) &#123;
  const startIndices = new Set();
  const endIndices = new Set();
  for (const match of str.matchAll(reQuoted)) &#123;
    const [start, end] = match.indices[1];
    startIndices.add(start);
    endIndices.add(end);
  &#125;
  let result = &#39;&#39;;
  for (let index=0; index &lt; str.length; index++) &#123;
    if (startIndices.has(index)) &#123;
      result += &#39;[&#39;;
    &#125; else if (endIndices.has(index+1)) &#123;
      result += &#39;]&#39;;
    &#125; else &#123;
      result += &#39; &#39;;
    &#125;
  &#125;
  return result;
&#125;
console.log(pointToQuotedText(&#39;They said “hello” and “goodbye”.&#39;));
// &#39;           [   ]       [     ]  &#39;
</code></pre>
<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><h6 id="1-公共实例字段"><a href="#1-公共实例字段" class="headerlink" title="(1) 公共实例字段"></a>(1) 公共实例字段</h6><p>公共类字段允许我们使用赋值运算符 (=) 将实例属性添加到类定义中。下面是一个计数器的例子：</p>
<pre><code class="javascript">import React, &#123; Component &#125; from &quot;react&quot;;

export class Incrementor extends Component &#123;
  constructor() &#123;
    super();
    this.state = &#123;
      count: 0,
    &#125;;
    this.increment = this.increment.bind(this);
  &#125;
  increment() &#123;
    this.setState(&#123; count: this.state.count + 1 &#125;);
  &#125;
  render() &#123;
    return (
      &lt;button onClick=&#123;this.increment&#125;&gt;Increment: &#123;this.state.count&#125;&lt;/button&gt;
    );
  &#125;
&#125;
</code></pre>
<p>在这个例子中，在构造函数中定义了实例字段和绑定方法，通过新的类语法，可以使代码更加直观。新的公共类字段语法允许我们直接将实例属性作为属性添加到类上，而无需使用构造函数方法。这样就简化了类的定义，使代码更加简洁、可读：</p>
<pre><code class="javascript">import React from &quot;react&quot;;

export class Incrementor extends React.Component &#123;
  state = &#123; count: 0 &#125;;
  increment = () =&gt; this.setState(&#123; count: this.state.count + 1 &#125;);
  render = () =&gt; (
    &lt;button onClick=&#123;this.increment&#125;&gt;Increment: &#123;this.state.count&#125;&lt;/button&gt;
  );
&#125;
</code></pre>
<p>有些小伙伴可能就疑问了，这个功能很早就可以使用了呀。但是它现在还不是标准的 ECMAScript，默认是不开启的，如果使用 create-react-app 创建 React 项目，那么它默认是启用的，否则我们必须使用正确的babel插件才能正常使用（@babel/preset-env）。<br>下面来看看关于公共实例字段的注意事项：<br>公共实例字段存在于每个创建的类实例上。它们要么是在Object.defineProperty()中添加，要么是在基类中的构造时添加（构造函数主体执行之前执行），要么在子类的super()返回之后添加：</p>
<pre><code class="javascript">class Incrementor &#123;
  count = 0
&#125;
const instance = new Incrementor();
console.log(instance.count); // 0
</code></pre>
<p>未初始化的字段会自动设置为 undefined：</p>
<pre><code class="javascript">class Incrementor &#123;
  count
&#125;
const instance = new Incrementor();
console.assert(instance.hasOwnProperty(&#39;count&#39;));
console.log(instance.count);  // undefined
</code></pre>
<p>可以进行字段的计算：</p>
<pre><code class="javascript">const PREFIX = &#39;main&#39;;
class Incrementor &#123;
  [`$&#123;PREFIX&#125;Count`] = 0
&#125;
const instance = new Incrementor();
console.log(instance.mainCount);   // 0
</code></pre>
<h6 id="2-私有实例字段、方法和访问器"><a href="#2-私有实例字段、方法和访问器" class="headerlink" title="(2) 私有实例字段、方法和访问器"></a>(2) 私有实例字段、方法和访问器</h6><p>默认情况下，ES6 中所有属性都是公共的，可以在类外检查或修改。下面来看一个例子：</p>
<pre><code class="javascript">class TimeTracker &#123;
  name = &#39;zhangsan&#39;;
  project = &#39;blog&#39;;
  hours = 0;
  set addHours(hour) &#123;
    this.hours += hour;
  &#125;
  get timeSheet() &#123;
    return `$&#123;this.name&#125; works $&#123;this.hours || &#39;nothing&#39;&#125; hours on $&#123;this.project&#125;`;
  &#125;
&#125;
let person = new TimeTracker();
person.addHours = 2; // 标准 setter
person.hours = 4;    // 绕过 setter 进行设置
person.timeSheet;
</code></pre>
<p>可以看到，在类中没有任何措施可以防止在不调用 setter 的情况下更改属性。<br>而私有类字段将使用哈希#前缀定义，从上面的示例中，可以修改它以包含私有类字段，以防止在类方法之外更改属性：</p>
<pre><code class="javascript">class TimeTracker &#123;
  name = &#39;zhangsan&#39;;
  project = &#39;blog&#39;;
  #hours = 0;  // 私有类字段
  set addHours(hour) &#123;
    this.#hours += hour;
  &#125;
  get timeSheet() &#123;
    return `$&#123;this.name&#125; works $&#123;this.#hours || &#39;nothing&#39;&#125; hours on $&#123;this.project&#125;`;
  &#125;
&#125;
let person = new TimeTracker();
person.addHours = 4; // 标准 setter
person.timeSheet     // zhangsan works 4 hours on blog
当尝试在 setter 方法之外修改私有类字段时，就会报错：
person.hours = 4 // Error Private field &#39;#hours&#39; must be declared in an enclosing class
</code></pre>
<p>还可以将方法或 getter/setter 设为私有，只需要给这些方法名称前面加#即可：</p>
<pre><code class="javascript">class TimeTracker &#123;
  name = &#39;zhangsan&#39;;
  project = &#39;blog&#39;;
  #hours = 0;   // 私有类字段
  set #addHours(hour) &#123;
    this.#hours += hour;
  &#125;
  get #timeSheet() &#123;
    return `$&#123;this.name&#125; works $&#123;this.#hours || &#39;nothing&#39;&#125; hours on $&#123;this.project&#125;`;
  &#125;
  constructor(hours) &#123;
    this.#addHours = hours;
    console.log(this.#timeSheet);
  &#125;
&#125;
let person = new TimeTracker(4); // zhangsan works 4 hours on blog
</code></pre>
<p>由于尝试访问对象上不存在的私有字段会发生异常，因此需要能够检查对象是否具有给定的私有字段。可以使用 in 运算符来检查对象上是否有私有字段：</p>
<pre><code class="javascript">class Example &#123;
  #field
  static isExampleInstance(object) &#123;
    return #field in object;
  &#125;
&#125;
</code></pre>
<h6 id="3-静态公共字段"><a href="#3-静态公共字段" class="headerlink" title="(3) 静态公共字段"></a>(3) 静态公共字段</h6><p>在ES6中，不能在类的每个实例中访问静态字段或方法，只能在原型中访问。ES 2022 提供了一种在 JavaScript 中使用 static 关键字声明静态类字段的方法。下面来看一个例子：</p>
<pre><code class="javascript">class Shape &#123;
  static color = &#39;blue&#39;;
  static getColor() &#123;
    return this.color;
  &#125;
  getMessage() &#123;
    return `color：$&#123;this.color&#125;` ;
  &#125;
&#125;
</code></pre>
<p>可以从类本身访问静态字段和方法：</p>
<pre><code class="javascript">console.log(Shape.color); // blue
console.log(Shape.getColor()); // blue
console.log(&#39;color&#39; in Shape); // true
console.log(&#39;getColor&#39; in Shape); // true
console.log(&#39;getMessage&#39; in Shape); // false
</code></pre>
<p>实例不能访问静态字段和方法：</p>
<pre><code class="javascript">const shapeInstance = new Shape();
console.log(shapeInstance.color); // undefined
console.log(shapeInstance.getColor); // undefined
console.log(shapeInstance.getMessage());// color：undefined
</code></pre>
<p>静态字段只能通过静态方法访问：</p>
<pre><code class="javascript">console.log(Shape.getColor()); // blue
console.log(Shape.getMessage()); //TypeError: Shape.getMessage is not a function
</code></pre>
<p>这里的 Shape.getMessage() 就报错了，因为 getMessage 不是一个静态函数，所以它不能通过类名 Shape 访问。可以通过以下方式来解决这个问题：</p>
<pre><code class="javascript">getMessage() &#123;
  return `color：$&#123;Shape.color&#125;` ;
&#125;
</code></pre>
<p>静态字段和方法是从父类继承的：</p>
<pre><code class="javascript">class Rectangle extends Shape &#123; &#125;

console.log(Rectangle.color); // blue
console.log(Rectangle.getColor()); // blue
console.log(&#39;color&#39; in Rectangle); // true
console.log(&#39;getColor&#39; in Rectangle); // true
console.log(&#39;getMessage&#39; in Rectangle); // false
</code></pre>
<h6 id="4-静态私有字段和方法"><a href="#4-静态私有字段和方法" class="headerlink" title="(4) 静态私有字段和方法"></a>(4) 静态私有字段和方法</h6><p>与私有实例字段和方法一样，静态私有字段和方法也使用哈希 (#) 前缀来定义：</p>
<pre><code class="javascript">class Shape &#123;
  static #color = &#39;blue&#39;;
  static #getColor() &#123;
    return this.#color;
  &#125;
  getMessage() &#123;
    return `color：$&#123;Shape.#getColor()&#125;` ;
  &#125;
&#125;
const shapeInstance = new Shape();
shapeInstance.getMessage(); // color：blue
</code></pre>
<p>私有静态字段有一个限制：只有定义私有静态字段的类才能访问该字段。这可能在使用 this 时导致出乎意料的情况：</p>
<pre><code class="javascript">class Shape &#123;
 static #color = &#39;blue&#39;;
 static #getColor() &#123;
   return this.#color;
 &#125;
 static getMessage() &#123;
   return `color：$&#123;this.#color&#125;` ;
 &#125;
 getMessageNonStatic() &#123;
   return `color：$&#123;this.#getColor()&#125;` ;
 &#125;
&#125;
class Rectangle extends Shape &#123;&#125;

console.log(Rectangle.getMessage()); // Uncaught TypeError: Cannot read private member #color from an object whose class did not declare it
const rectangle = new Rectangle();
console.log(rectangle.getMessageNonStatic()); // TypeError: Cannot read private member #getColor from an object whose class did not declare it
</code></pre>
<p>在这个例子中，this 指向的是 Rectangle 类，它无权访问私有字段 #color。当我们尝试调用 Rectangle.getMessage() 时，它无法读取 #color 并抛出了 TypeError。可以这样来进行修改：</p>
<pre><code class="javascript">class Shape &#123;
  static #color = &#39;blue&#39;;
  static #getColor() &#123;
    return this.#color;
  &#125;
  static getMessage() &#123;
    return `$&#123;Shape.#color&#125;`;
  &#125;
  getMessageNonStatic() &#123;
    return `color：$&#123;Shape.#getColor()&#125; color`;
  &#125;
&#125;

class Rectangle extends Shape &#123;&#125;
console.log(Rectangle.getMessage()); // color：blue
const rectangle = new Rectangle();
console.log(rectangle.getMessageNonStatic()); // color：blue
</code></pre>
<h6 id="5-类静态初始化块"><a href="#5-类静态初始化块" class="headerlink" title="(5) 类静态初始化块"></a>(5) 类静态初始化块</h6><p>静态私有和公共字段只能让我们在类定义期间执行静态成员的每个字段初始化。如果我们需要在初始化期间像 try…catch 一样进行异常处理，就不得不在类之外编写此逻辑。该规范就提供了一种在类声明/定义期间评估静态初始化代码块的优雅方法，可以访问类的私有字段。<br>先来看一个例子：</p>
<pre><code class="javascript">class Person &#123;
    static GENDER = &quot;Male&quot;
    static TOTAL_EMPLOYED;
    static TOTAL_UNEMPLOYED;
    try &#123;
        // ...
    &#125; catch &#123;
        // ...
    &#125;
&#125;
</code></pre>
<p>上面的代码就会引发错误，可以使用类静态块来重构它，只需将try…catch包裹在 static 中即可：</p>
<pre><code class="javascript">class Person &#123;
    static GENDER = &quot;Male&quot;
    static TOTAL_EMPLOYED;
    static TOTAL_UNEMPLOYED;
    static &#123;
    try &#123;
            // ...
        &#125; catch &#123;
            // ...
        &#125;
    &#125;
&#125;
</code></pre>
<p>此外，类静态块提供对词法范围的私有字段和方法的特权访问。这里需要在具有实例私有字段的类和同一范围内的函数之间共享信息的情况下很有用。</p>
<pre><code class="javascript">let getData;

class Person &#123;
  #x
  constructor(x) &#123;
    this.#x = &#123; data: x &#125;;
  &#125;
  static &#123;
    getData = (obj) =&gt; obj.#x;
  &#125;
&#125;

function readPrivateData(obj) &#123;
  return getData(obj).data;
&#125;

const john = new Person([2,4,6,8]);

readPrivateData(john); // [2,4,6,8]
</code></pre>
<p>这里，Person 类与 readPrivateData 函数共享了私有实例属性。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/03/ReactHooks/" rel="prev" title="React Hooks">
      <i class="fa fa-chevron-left"></i> React Hooks
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/27/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/" rel="next" title="移动端适配方案 viewport">
      移动端适配方案 viewport <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#Top-level-Await"><span class="nav-text">Top-level Await</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-hasOwn"><span class="nav-text">Object.hasOwn()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#at"><span class="nav-text">at()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#error-cause"><span class="nav-text">error.cause</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95"><span class="nav-text">正则表达式匹配索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E5%85%AC%E5%85%B1%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5"><span class="nav-text">(1) 公共实例字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E7%A7%81%E6%9C%89%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="nav-text">(2) 私有实例字段、方法和访问器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E9%9D%99%E6%80%81%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5"><span class="nav-text">(3) 静态公共字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-%E9%9D%99%E6%80%81%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-text">(4) 静态私有字段和方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-%E7%B1%BB%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="nav-text">(5) 类静态初始化块</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jwh"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">jwh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jwh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
